# -*- coding: utf-8 -*-
"""
Created on Wed Aug 14 13:19:04 2019

@author: Selter
"""


import numpy as np
import matplotlib.pyplot as plt
import spectrum as spec
import sys
sys.path.append('C:/Users/Selter/OneDrive/projects/python-utils')
import brukerplot as bruk

def RMS(dat,model):
    NP = len(dat)
    delta2 = 0
    for n in range(len(dat)):
        delta2 = delta2 + (dat[n]-model[n])**2
    RMS = np.sqrt(1/NP*delta2)
    return RMS


#######################################################################
#    Define the function for the D_zz in the LAF
#    takes in the three euler angles alpha,beta, gamma
#    Alpha and Beta can be generated by the ZCW scheme from spectrum.py
#    Gamma has then to be added
#    This is similar to the way SIMPSON deals with this
#######################################################################

##############################################################################################################################################
# Calculation of the zz-component of the dipolar coupling tensor in the Laboratory Frame of Reference
# 
# For reference, check the Supplementary Information of:
# Phys. Chem. Chem. Phys., 2012, 14, 2727â€“2734
# Hackel et al."The trehalose coating effect on the internal protein dynamics"


# These provide the instantaneous frequencies at that point in time for a specific set of Euler angles

def D_LF_zz_CH(t,a,b,c,d_CH,w_mas):
    """calculates the instantaneous frequency of the dipolar coupling for a specific set of Euler angles
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = d_CH*(-(1/2)*((np.cos(b)**2)-1)*np.cos(2*w_mas*t+2*c)-np.sqrt(2.0)*np.sin(b)*np.cos(b)*np.cos(w_mas*t+c))
    return result


def D_LF_zz_CH2_p(t,a,b,c,d_CH,w_MAS):
    """calculates the instantaneous frequency of the dipolar coupling for a specific set of Euler angles
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = d_CH*((1/6*np.cos(2*a)*((np.cos(b)**2)-1)+(np.sqrt(2)/3)*np.cos(a)*np.sin(b)*np.cos(b))*np.cos(2*w_MAS*t+2*c)
    +(-(2/3)*np.cos(a)*np.sin(a)*np.cos(b)-(np.sqrt(2)/3)*np.sin(a)*np.sin(b))*np.sin(2*w_MAS*t+2*c)
    +((np.sqrt(2)/3)*np.cos(2*a)*np.cos(b)*np.sin(b)-(2/3)*np.cos(a)*np.cos(2*b))*np.cos(w_MAS*t+c)
    +((-2*np.sqrt(2)/3)*np.cos(2*a)*np.sin(a)*np.sin(b)+(2/3)*np.sin(a)*np.cos(b))*np.sin(w_MAS*t+c))
    return result

def D_LF_zz_CH2_m(t,a,b,c,d_CH,w_MAS):
    """calculates the instantaneous frequency of the dipolar coupling for a specific set of Euler angles
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = d_CH*((1/6*np.cos(2*a)*((np.cos(b)**2)-1)-(np.sqrt(2)/3)*np.cos(a)*np.sin(b)*np.cos(b))*np.cos(2*w_MAS*t+2*c)
    +(-(2/3)*np.cos(a)*np.sin(a)*np.cos(b)+(np.sqrt(2)/3)*np.sin(a)*np.sin(b))*np.sin(2*w_MAS*t+2*c)
    +((np.sqrt(2)/3)*np.cos(2*a)*np.cos(b)*np.sin(b)+(2/3)*np.cos(a)*np.cos(2*b))*np.cos(w_MAS*t+c)
    +((-2*np.sqrt(2)/3)*np.cos(2*a)*np.sin(a)*np.sin(b)-(2/3)*np.sin(a)*np.cos(b))*np.sin(w_MAS*t+c))
    return result


#######################################################################    
# Integral forms of the equations above, used to calculate the acquired phase at any point in time for a specific set of euler angles

# Integrals for the CH spinsystem    
def INT_D_LF_zz_CH(t,b,c,d_CH,w_mas):
    """calculates the accumulated phase for a specific set of Euler angles
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = d_CH*((np.sin(b)*(-2*np.sqrt(2)*np.cos(b)+np.cos(c+w_mas*t)*np.sin(b))*np.sin(c+w_mas*t))/(2*w_mas)-(np.sin(b)*(-2*np.sqrt(2)*np.cos(b)+np.cos(c+w_mas*0)*np.sin(b))*np.sin(c+w_mas*0))/(2*w_mas))
    return result*360

# Alternate form of the function above    
def INT2_D_LF_zz_CH(t,b,c,d_CH,w_mas):
    """calculates the accumulated phase for a specific set of Euler angles
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = -d_CH*np.sin(c+w_mas*t)*(0.5*(np.cos(b)**2-1)*np.cos(w_mas*t+c)+np.sqrt(2)*np.sin(b)*np.cos(b))/w_mas-(-d_CH*np.sin(c+w_mas*0)*(0.5*(np.cos(b)**2-1)*np.cos(w_mas*0+c)+np.sqrt(2)*np.sin(b)*np.cos(b))/w_mas)
    return result*360


def coeff_A_p(a,b):
    """ Calculates coefficient A, angles in radians """
    return 1/6*np.cos(2*a)*(np.cos(b)**2-1)+np.sqrt(2)/3*np.cos(a)*np.sin(b)*np.cos(b)

def coeff_B_p(a,b):
    """ Calculates coefficient B, angles in radians """
    return -2/3*np.cos(a)*np.sin(a)*np.cos(a)-np.sqrt(2)/3*np.sin(a)*np.sin(b)

def coeff_C_p(a,b):
    """ Calculates coefficient C, angles in radians """
    return np.sqrt(2)/3*np.cos(2*a)*np.cos(b)*np.sin(b)-2/3*np.cos(a)*np.cos(2*b)

def coeff_D_p(a,b):
    """ Calculates coefficient D, angles in radians """
    return -2*np.sqrt(2)/3*np.cos(a)*np.sin(a)*np.sin(b)+2/3*np.sin(a)*np.cos(b)

def INT_D_LF_zz_CH2_p(t,a,b,c,d_CH,w_MAS):
    """calculates the instantaneous frequency of the dipolar coupling for a specific set of Euler angles;
    assumes CH2 spinsystem; phase_1 ('positive')
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = -1.0*(d_CH*(-1.0*coeff_A_p(a,b)*np.sin(2*(c+w_MAS*t))+coeff_B_p(a,b)*np.cos(2*(c+w_MAS*t))+coeff_B_p(a,b)-2*coeff_C_p(a,b)*np.sin(c+w_MAS*t)+2*coeff_D_p(a,b)*np.cos(c+w_MAS*t))/(2*w_MAS))-(-1.0*(d_CH*(-1.0*coeff_A_p(a,b)*np.sin(2*(c+w_MAS*0))+coeff_B_p(a,b)*np.cos(2*(c+w_MAS*0))+coeff_B_p(a,b)-2*coeff_C_p(a,b)*np.sin(c+w_MAS*0)+2*coeff_D_p(a,b)*np.cos(c+w_MAS*0))/(2*w_MAS)))

    return result*360



def coeff_A_m(a,b):
    """ Calculates coefficient A, angles in radians """
    return 1/6*np.cos(2*a)*(np.cos(b)**2-1)-np.sqrt(2)/3*np.cos(a)*np.sin(b)*np.cos(b)

def coeff_B_m(a,b):
    """ Calculates coefficient B, angles in radians """
    return -2/3*np.cos(a)*np.sin(a)*np.cos(a)+np.sqrt(2)/3*np.sin(a)*np.sin(b)

def coeff_C_m(a,b):
    """ Calculates coefficient C, angles in radians """
    return np.sqrt(2)/3*np.cos(2*a)*np.cos(b)*np.sin(b)+2/3*np.cos(a)*np.cos(2*b)

def coeff_D_m(a,b):
    """ Calculates coefficient D, angles in radians """
    return -2*np.sqrt(2)/3*np.cos(a)*np.sin(a)*np.sin(b)-2/3*np.sin(a)*np.cos(b)

def INT_D_LF_zz_CH2_m(t,a,b,c,d_CH,w_MAS):
    """calculates the instantaneous frequency of the dipolar coupling for a specific set of Euler angles;
    assumes CH2 spinsystem; phase_1 ('positive')
    - t     point in time or time axis
    - a     euler angle alpha in rad
    - b     euler angle beta in rad
    - c     euler angle beta in rad
    - d_CH  dipolar coupling constant
    - w_MAS MAS frequency in rad/s
    """
    result = -1.0*(d_CH*(-1.0*coeff_A_m(a,b)*np.sin(2*(c+w_MAS*t))+coeff_B_m(a,b)*np.cos(2*(c+w_MAS*t))+coeff_B_m(a,b)-2*coeff_C_m(a,b)*np.sin(c+w_MAS*t)+2*coeff_D_m(a,b)*np.cos(c+w_MAS*t))/(2*w_MAS))-(-1.0*(d_CH*(-1.0*coeff_A_m(a,b)*np.sin(2*(c+w_MAS*0))+coeff_B_m(a,b)*np.cos(2*(c+w_MAS*0))+coeff_B_m(a,b)-2*coeff_C_m(a,b)*np.sin(c+w_MAS*0)+2*coeff_D_m(a,b)*np.cos(c+w_MAS*0))/(2*w_MAS)))

    return result*360
##############################################################################################################################################



##############################################################################################################################################
# Main function to generate a DIPSHIFT curve for either the CH or CH2 case
# relies on powder averaging from spectrum.py
def calc_curve(d_CH,MAS,t_axis,N_angles=5,g_angles=21,case='CH2',verbose=True,normalize=True,file=False):
    t_rotor = 1/MAS
    time_axis = t_axis
    result = np.zeros(len(time_axis))
    w_MAS = MAS*2*np.pi
    
    # generate the list of gamma angles
    c_list = np.linspace(0,360,g_angles)
    rad_c_list = np.deg2rad(c_list)
    
    if verbose == True:
        print('### DIPSHIFT CALCULATION FINISHED ###')
        # output of what is going to happen
        
        print(' ')
               
        print('###   DIPSHIFT CURVE CALCULATION  ###')
        print('MAS frequency: '+str(MAS))    
        print('Rotor period: '+str(t_rotor))    
        print('number of points: '+str(len(time_axis)))        
        print('total number of euler angle pairs: '+str(spec.fibo(N_angles)*g_angles))

    
        if case == 'CH':
            
            #The CH case only depends on euler angles beta and gamma, therefore a simpler powder averaging can be used in this case
            cryst_file = spec.BETA(N_angles,deg=False,verbose=False)
            n_cryst = len(cryst_file)
            zresult = 0
            ###################################################
            # Calculation for the CH case
            for k in range(n_cryst):
                for i in range(g_angles):
                    current = INT_D_LF_zz_CH(time_axis,cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    cos = np.cos(np.deg2rad(current))
                    result = result + cos*cryst_file[k,1]/(n_cryst*g_angles)
                    zero_current = INT_D_LF_zz_CH(0,cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zero_cos = np.cos(np.deg2rad(zero_current))
                    zresult = zresult + zero_cos*cryst_file[k,1]/(n_cryst*g_angles)
            ###################################################
        
        elif case == 'CH2':
                
            cryst_file = spec.ZCW(N_angles,deg=False,verbose=False)
            n_cryst = len(cryst_file)
            result1 = np.zeros(len(time_axis))
            result2 = np.zeros(len(time_axis))
            zresult = 0
            zresult1 = 0
            zresult2 = 0
            ###################################################
            # Calculation for the CH2 case
            for k in range(n_cryst):
                for i in range(g_angles):
                    phase_m = INT_D_LF_zz_CH2_m(time_axis,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    phase_p = INT_D_LF_zz_CH2_p(time_axis,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    cos1 = np.cos(np.deg2rad(phase_p)-np.deg2rad(phase_m))
                    cos2 = np.cos(np.deg2rad(phase_p)+np.deg2rad(phase_m))
                    result1 = result1 + cos1*cryst_file[k,2]/(n_cryst*g_angles)
                    result2 = result2 + cos2*cryst_file[k,2]/(n_cryst*g_angles)
                    zphase_m = INT_D_LF_zz_CH2_m(0,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zphase_p = INT_D_LF_zz_CH2_p(0,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zcos1 = np.cos(np.deg2rad(zphase_p)-np.deg2rad(zphase_m))
                    zcos2 = np.cos(np.deg2rad(zphase_p)+np.deg2rad(zphase_m))
                    zresult1 = zresult1 + zcos1*cryst_file[k,2]/(n_cryst*g_angles)
                    zresult2 = zresult2 + zcos2*cryst_file[k,2]/(n_cryst*g_angles)
            result = 0.5*result1+0.5*result2
            zresult = 0.5*zresult1+0.5*zresult2
            ###################################################
                
        else:
             
            print('################################')
            print('### !!! unsupported case !!! ###')
            print('Only "CH" and "CH2" are supported at this point')
            print('### CALCULATION STOPPED ###')
            return
    
        if normalize == True:
            result = result/zresult
        
        if file == False:
            data = np.array([time_axis,result])
            data2 = data.transpose()
            return data2
        else:
            data = np.array([time_axis,result])
            data2 = data.transpose()
                   ### DIPSHIFT CALCULATION FINISHED ###
            print('###       saving data             ###')
            np.savetxt('DIPSHIFT_DD_'+str(d_CH)+'_Hz_MAS_'+str(d_CH)+'_Hz.dat',data2,fmt='%.8f',delimiter=' ')
            print('### '+'DIPSHIFT_DD_'+str(d_CH)+'_Hz_MAS_'+str(d_CH)+'_Hz.dat'+' ####')
     
        
        
    else:
         
        if case == 'CH':
            
            #The CH case only depends on euler angles beta and gamma, therefore a simpler powder averaging can be used in this case
            cryst_file = spec.BETA(N_angles,deg=False,verbose=False)
            n_cryst = len(cryst_file)
            zresult = 0
            ###################################################
            # Calculation for the CH case
            for k in range(n_cryst):
                for i in range(g_angles):
                    current = INT_D_LF_zz_CH(time_axis,cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    cos = np.cos(np.deg2rad(current))
                    result = result + cos*cryst_file[k,1]/(n_cryst*g_angles)
                    zero_current = INT_D_LF_zz_CH(0,cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zero_cos = np.cos(np.deg2rad(zero_current))
                    zresult = zresult + zero_cos*cryst_file[k,1]/(n_cryst*g_angles)
            ###################################################
        
        elif case == 'CH2':
                
            cryst_file = spec.ZCW(N_angles,deg=False,verbose=False)
            n_cryst = len(cryst_file)
            result1 = np.zeros(len(time_axis))
            result2 = np.zeros(len(time_axis))
            zresult = 0
            zresult1 = 0
            zresult2 = 0
            ###################################################
            # Calculation for the CH2 case
            for k in range(n_cryst):
                for i in range(g_angles):
                    phase_m = INT_D_LF_zz_CH2_m(time_axis,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    phase_p = INT_D_LF_zz_CH2_p(time_axis,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    cos1 = np.cos(np.deg2rad(phase_p)-np.deg2rad(phase_m))
                    cos2 = np.cos(np.deg2rad(phase_p)+np.deg2rad(phase_m))
                    result1 = result1 + cos1*cryst_file[k,2]/(n_cryst*g_angles)
                    result2 = result2 + cos2*cryst_file[k,2]/(n_cryst*g_angles)
                    zphase_m = INT_D_LF_zz_CH2_m(0,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zphase_p = INT_D_LF_zz_CH2_p(0,cryst_file[k,0],cryst_file[k,1],rad_c_list[i],d_CH,w_MAS)
                    zcos1 = np.cos(np.deg2rad(zphase_p)-np.deg2rad(zphase_m))
                    zcos2 = np.cos(np.deg2rad(zphase_p)+np.deg2rad(zphase_m))
                    zresult1 = zresult1 + zcos1*cryst_file[k,2]/(n_cryst*g_angles)
                    zresult2 = zresult2 + zcos2*cryst_file[k,2]/(n_cryst*g_angles)
            result = 0.5*result1+0.5*result2
            zresult = 0.5*zresult1+0.5*zresult2
            ###################################################
            
        else:
            print('################################')
            print('### !!! unsupported case !!! ###')
            print('Only "CH" and "CH2" are supported at this point')
            print('### CALCULATION STOPPED ###')
            return
    
        if normalize == True:
#            result = result/zresult
            result = result/result.max()
        
        if file == False:
            data = np.array([time_axis,result])
            data2 = data.transpose()
            return data2
        else:
            data = np.array([time_axis,result])
            data2 = data.transpose()
          
            np.savetxt('DIPSHIFT_DD_'+str(d_CH)+'_Hz_MAS_'+str(MAS)+'_Hz_'+str(case)+'.dat',data2,fmt='%.8f',delimiter=' ')
           
                 
            
    return data2
 

def create_lib(dipoles,t_axis,v_MAS,N_angles=5,g_angles=21,case='CH'):
    for n in range(len(dipoles)):
        calc_curve(dipoles[n],v_MAS,t_axis,5,21,case=case,file=True,verbose=False)    
    return


def compare_data(exp,dipoles,MAS,t_axis,case='CH'):
    rms_results = np.zeros((len(dipoles),2))
    for n in range(len(dipoles)):
  
        sim = np.loadtxt('DIPSHIFT_DD_'+str(dipoles[n])+'_Hz_MAS_'+str(MAS)+'_Hz_'+str(case)+'.dat')
        rms_results[n,0] = dipoles[n]
        rms_results[n,1] = RMS(exp,sim[:,1])
        
        
    
    minidx = np.where(rms_results[:,1] == np.amin(rms_results[:,1]))
    print(int(minidx[0]))
    minidx=int(minidx[0])
    return rms_results
    
##############################################################################################################################################
##############################################################################################################################################


class dipshift(object):
    """General Object to handle dipshift measurements by pseudo2D
    
    expects the data being pre-processed via rowext in Topsin 
    or euqivalent treatment prior to use
    
    
    """
    
    
    #----------------------------------
    def __init__(self, path, expno):
        """"Initialize the class
        
        nothing fancy, yet
        """
        self.path = path
        self.expno = expno
    #----------------------------------
    

    def calcnoise(self,dat,noise_reg=(400,200)):
        """"Caculates the noise number based on  numpy.std(), which is essentially the same as the Bruker thing
        """
        self.nidx0 = (np.abs(self.xaxis - noise_reg[0])).argmin()
        self.nidx1 = (np.abs(self.xaxis - noise_reg[1])).argmin()
        self.noise = np.std(dat[self.nidx0:self.nidx1])
        return self.noise



    def proc_pseudo2d(self,start_procno,npoints,region=(0,20),noise_reg=(400,200),normalize=False,method='integration'):
            
            self.region = np.array(region)
            self.npoints = npoints
            self.sl_error = np.zeros((self.npoints))
            
            #define the fitting range
            self.integrals = np.zeros((self.npoints))
            
            ###############################################################################
            
            #----------------------------------
            #Do the integration over all procnos
            for n in range(self.npoints):
                
            #   load the data and find the spectral limits
                self.spectrum = bruk.bruker1d(self.path,self.expno,procno=start_procno+n)
                self.x, self.y = self.spectrum.plot1d()
                self.xaxis = np.array(self.x)
                self.zerofilling_factor,self.sn_fac = self.spectrum.calc_zfratio()
                
                
                #check for the regions to be ordered correctly
                if self.region[0] < self.region[1]:
                    tmp = self.region[0]
                    self.region[0] = self.region[1]
                    self.region[1] = tmp
                    
                if noise_reg[0] < noise_reg[1]:
                    tmp = noise_reg[0]
                    noise_reg[0] = noise_reg[1]
                    noise_reg[1] = tmp
                
                self.nidx0 = (np.abs(self.xaxis - noise_reg[0])).argmin()
                self.nidx1 = (np.abs(self.xaxis - noise_reg[1])).argmin()
                self.noise = np.std(self.y[self.nidx0:self.nidx1])
                
                
                #Do the integration for every defined region
                self.idx0 = (np.abs(self.xaxis - self.region[0])).argmin()
                self.idx1 = (np.abs(self.xaxis - self.region[1])).argmin()
                
                
                self.np_integral = self.idx1-self.idx0
                if method == 'findmax':
                    self.integrals[n] = self.y[self.idx0:self.idx1].max()
                    self.sl_error[n] = self.noise
                    
                elif method == 'integration':
                    for p in range(self.idx1-self.idx0):
    #                    self.integrals[n] = self.integrals[n] + self.y[self.idx0+p]
                        self.integrals[n] = self.integrals[n] + self.y[self.idx0+p]/self.zerofilling_factor
                        self.sl_error[n] = self.noise*np.sqrt(self.np_integral)*self.sn_fac
                else:
                    print('Unknown/unsupported method')
                    print('processing aborted')
                    break
                
   

            if normalize == True:
                self.norm_integrals = np.zeros_like(self.integrals)
                self.norm_sl_error = np.zeros_like(self.sl_error)
                
                self.norm_integrals[:] = self.integrals[:]/self.integrals[:].max()*100
                self.norm_sl_error[:] = self.sl_error[:]/self.integrals[:].max()*100
                return self.norm_integrals, self.norm_sl_error
            #----------------------------------   
            ###############################################################################
            else:
                
                return  self.integrals, self.sl_error
    

#
########################################################################
## Experimental parameter:
#v_MAS = 10e3
#inc = 5e-6
#dipole= 16e3
########################################################################
#fig1 = plt.figure()
#noises = (0.01,0.02,0.03,0.04,0.05,0.075)
#dipoles = np.arange(0,20e3,0.2e3)
#
#
#
#
#create_lib(dipoles,inc,v_MAS,5,21,case='CH2')
#
#for n in noises:
## generate noisy pseudo-data
#    data= calc_curve(dipole,v_MAS,inc,5,21,case='CH2',file=True)
#    print(len(data))
#        
#    noise_figure = n
#    
#    noise = np.random.normal(0,noise_figure,len(data))
#    exp =data[:,1]+noise
#    rms = RMS(exp,data[:,1])
#    print(rms)
#   
#    rms_results = np.zeros((len(dipoles),2))
#    
#    for n in range(len(dipoles)):
#  
#        data = np.loadtxt('DIPSHIFT_DD_'+str(dipoles[n])+'_Hz_MAS_'+str(v_MAS)+'_Hz_CH2.dat')
#        rms_results[n,0] = dipoles[n]
#        rms_results[n,1] = RMS(exp,data[:,1])
#        
#        
#    
#    minidx = np.where(rms_results[:,1] == np.amin(rms_results[:,1]))
#    print(int(minidx[0]))
#    minidx=int(minidx[0])
#    
#    
#    
#    
#    plt.plot(rms_results[:,0],rms_results[:,1])
#    plt.errorbar(rms_results[minidx,0],rms_results[minidx,1],xerr=rms_results[minidx,1]*rms_results[minidx,0],fmt='o', color='tab:red', capsize=8, markersize=6,mfc='tab:red')
#plt.show()
#






































